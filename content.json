{"pages":[{"title":"","text":"const heads = { val: 1, next: { val: 2, next: { val: 3, next: { val: 4, next: { val: 5, next: null } } } } } function reveseLink(linkList) { let pre = null let cur = linkList while (cur != null) { let temp = cur.next cur.next = pre console.log(1, cur) console.log(1.5, pre) pre = cur console.log(2, pre) cur = temp console.log(3, cur) } return pre } console.log(reveseLink(heads))","link":"/docs/linkList.js"},{"title":"","text":"var twoSum = function (nums, target) { let map = new Map() for (let [index, element] of nums.entries()) { if (map.has(element)) { map.get(element).add(index) } else { map.set(element, new Set([index])) } } for (let [index, element] of nums.entries()) { let second = target - element const indexs = map.get(second) if (indexs) { for (let indexNum of [...indexs]) { if (indexNum !== index) { return [index, indexNum] } } } } }; console.log(twoSum([1,2,3,4], 5))","link":"/docs/twoSums.js"}],"posts":[{"title":"996?","text":"中国社科院曾经发布过一个报告，说2017年我国每天工作时间超过8小时的人，占了42.2%。而且这不仅仅是中国的情况，日本，美国这些发达国家也普遍存在过劳。 这种现象虽然普遍，而且我们都身在其中。但仔细想想就会发现，其实”过劳”这件事，不太符合逻辑。 我们都知道，近两百年，人类整体的生产效率，那是一飞冲天啊。按说，生产效率上去了，单位工作时间的产出高了，那相应的工作时间应该减少才对啊。所以经济学家凯恩斯在1930年曾经做出一个有名的预测，他认为到2030年，人类的劳动时间每周15小时，就足够了。 现实是，很多互联网公司甚至开创了996模式，上午9点上班，下午9点下班，一周工作6天。我们还有724模式，一周7天24小时随时待命。你看，凯恩斯在1930年的预测错了。错的离谱，方向都错了。 问题是：他为什么错了？工具越高级，应该干活越省力才对。那为什么我们反而更累了呢？ 《过劳时代》这本书里提供了很多解释。比如，全球化把所有人拉到了同一个竞争平面上。你是在一个地方工作，但你不是在和一个地方的人竞争。一个美国的工人是和一个中国的工人，甚至是非洲的工人在竞争。所以，竞争强度增大了。再比如，消费主义盛行。你和身边的人越来越多的攀比，比房子比车比包包比度假酒店，你想挣钱的欲望就越大，所以只能拼命干活。等等。 但是，我觉得最有说服力的解释，不是这些。问题的根子不在别的，就在于生产工具本身。它越进化、越高级、效率越高、越好用，我们就用得越多，所以工作时间就越长。 这是一个很有意思的悖论。举个例子，过去我们上班，必须得到单位才行，和同事见了面，才能展开协作。很不方便，后来有了电脑，有了邮件，有了微信，按说是更方便、更省时间了。但是结果呢？你知道的，老板能随时在微信群里抓到我们说事，周末也行，深更半夜也行。你上班的时间能不更长吗？ 表面上看，工具的发明，总是解决一个现实问题的。有了斧头，砍树就更快。有了汽车，走得就更远。这是工具给我们提供的第一样东西，叫便利性。 但是，如果你只看到这一面，就忽略了一个更重要的东西，这也是工具带来的。你要解决问题，任何问题都是有它的时间空间边界的，工具一升级，边界内的问题，是被更高效的解决了，但是，这个时空边界本身也被打破了。于是，会出现新的问题，而且是更大的问题。 比如说，当年人们用马车，非常慢。后来，给车装上了发动机，这就成了汽车，速度提上去了。在有限的时空边界内，这就是一项改善。确定无疑的改善吧？那你说，会因为速度提上去了，所以，人旅行用的时间少了，所以车就会变少吗？当然不是啊。因为汽车打破了原来的时空限制，出现了全新的可能性。你就想，原来坐马车，你至少要带一个马车夫。现在呢？可以开汽车，一个人就可以开车，没有马车夫打扰了。车不仅是交通工具，它还是一个移动的私人空间了。所以就出现了一种新的行为方式，没有确定目的的开车兜风，这种行为模式就出现了。不去哪儿，就是带上女朋友开车去看看诗和远方。车的使用当然就越来越多。 当然，现实中远远不止是这一种情况了。因为车可以走得更远，所以，就一定会走得更远。因为可以走得更远，所以，整个社会的假设就变了，汽车旅馆就出现了，郊区景点和度假村就出现了，远离城区的购物中心，像奥特莱斯就出现了。这就反过来逼迫，你如果不能有汽车，你不能走得更远，你就没有办法享受社会基础设施提供的便利。它就会走到这个程度。 你看，这个过程就是：工具不仅为你解决了问题。工具还在你始料未及的地方，推开了一扇新的可能性的大门。这扇大门一旦推开，就再也关不上了，后面的人就会一涌而出，只会把门撑得越来越宽。这就是工具对人的反向塑造。 有句话叫，身怀利刃杀心自起。你身上有把刀，看见什么都想用上。对，工具虽然只是提供了某种可能，但是人性使然，我们总是倾向于要把这种可能性变成现实性。工具在可能性上推开了多大的空间，我们就一定会倾向于把这个空间填满。 理解了这个逻辑，再回到今天的主题，为什么劳动工具效率越来越高，我们却越来越忙呢？这么看来，答案就非常简单了。和全球化，消费主义有关，但关系没那么大。因为劳动工具让我们工作的可能性越来越高，我们就一定会把这个可能性填满，我们当然就会一直工作，所以越来越忙。 《过劳时代》这本书的解读人，李南南老师还开了一个脑洞。他说: 假如未来，你的工资不是按月计算，而是按秒计算。在你的面前，有一个计时器，你每多工作一秒，你的账上马上就会多一毛钱。结果会是什么？表面看起来，这对你只有好处没有坏处。首先，每天工作8小时，这就是一天2880块钱，不少吧？你收入提高了。更重要的是，你碎片时间的工作，比如，吃饭间歇、睡觉前给同事回个工作微信，也能计算报酬了，对你更公平了。好事吧？好工具。 但这是在你现在的时空边界下看问题。真实情况可能是，这个可能性的大门一旦打开，大多数人因为碎片时间也能挣钱，会工作到筋疲力尽才会停。如果不信，你现在到网吧里去看看那些打游戏挣积分通宵不睡的人，你就知道，如果真有那么一天，工作到筋疲力尽那就是我们的未来。 来自《过劳时代》的解读— 为什么我们的工作时间越来越长？","link":"/2019/05/23/some-talk/"},{"title":"REDIS（一）：基础介绍","text":"一、概述Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 二、数据类型 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素对单个或者多个元素进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素检查一个元素是否存在于集合中计算交集、并集、差集从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对获取所有键值对检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素根据分值范围或者成员来获取元素计算一个键的排名 What Redis data structures look like STRING 12345678&gt; set hello worldOK&gt; get hello\"world\"&gt; del hello(integer) 1&gt; get hello(nil) LIST 123456789101112131415161718192021&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) \"item\"2) \"item2\"3) \"item\"&gt; lindex list-key 1\"item2\"&gt; lpop list-key\"item\"&gt; lrange list-key 0 -11) \"item2\"2) \"item\" SET 123456789101112131415161718192021222324252627&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) \"item\"2) \"item2\"3) \"item3\"&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) \"item\"2) \"item3\" HASH 123456789101112131415161718192021222324&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\"3) \"sub-key2\"4) \"value2\"&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1\"value1\"&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\" ZSET 12345678910111213141516171819202122232425&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) \"member1\"2) \"728\"3) \"member0\"4) \"982\"&gt; zrangebyscore zset-key 0 800 withscores1) \"member1\"2) \"728\"&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) \"member0\"2) \"982\" 三、数据结构字典dictht 是一个散列表结构，使用拉链法保存哈希冲突。 12345678/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */typedef struct dictht { dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;} dictht; 12345678910typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next;} dictEntry; Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。 1234567typedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */} dict; rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。 渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。 采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */int dictRehash(dict *d, int n) { int empty_visits = n * 10; /* Max number of empty buckets to visit. */ if (!dictIsRehashing(d)) return 0; while (n-- &amp;&amp; d-&gt;ht[0].used != 0) { dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(d-&gt;ht[0].size &gt; (unsigned long) d-&gt;rehashidx); while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) { d-&gt;rehashidx++; if (--empty_visits == 0) return 1; } de = d-&gt;ht[0].table[d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ while (de) { uint64_t h; nextde = de-&gt;next; /* Get the index in the new hash table */ h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask; de-&gt;next = d-&gt;ht[1].table[h]; d-&gt;ht[1].table[h] = de; d-&gt;ht[0].used--; d-&gt;ht[1].used++; de = nextde; } d-&gt;ht[0].table[d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; } /* Check if we already rehashed the whole table... */ if (d-&gt;ht[0].used == 0) { zfree(d-&gt;ht[0].table); d-&gt;ht[0] = d-&gt;ht[1]; _dictReset(&amp;d-&gt;ht[1]); d-&gt;rehashidx = -1; return 0; } /* More to rehash... */ return 1;} 跳跃表是有序集合的底层实现之一。 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。 在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。 与红黑树等平衡树相比，跳跃表具有以下优点： 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。 四、使用场景计数器可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 查找表例如 DNS 记录就很适合使用 Redis 进行存储。 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息 不过最好使用 Kafka、RabbitMQ 等消息中间件。 会话缓存可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 分布式锁实现在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。 可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它Set 可以实现交集、并集等操作，从而实现共同好友等功能。 ZSet 可以实现有序性操作，从而实现排行榜等功能。 五、Redis 与 Memcached两者都是非关系型内存键值数据库，主要有以下不同： 数据类型Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 数据持久化Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 分布式Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 六、键的过期时间Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 七、数据淘汰策略可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 策略 描述 volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random 从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰 allkeys-random 从所有数据集中任意选择数据进行淘汰 noeviction 禁止驱逐数据 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。 八、持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 RDB 持久化将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 AOF 持久化将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： 选项 同步频率 always 每个写命令都同步 everysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 九、事务一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。 事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 十、事件Redis 服务器是一个事件驱动程序。 文件事件服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。 Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。 时间事件服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。 时间事件又分为： 定时事件：是让一段程序在指定的时间之内执行一次； 周期性事件：是让一段程序每隔指定时间就执行一次。 Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。 事件的调度与执行服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下： 12345678910111213141516def aeProcessEvents(): # 获取到达时间离当前时间最接近的时间事件 time_event = aeSearchNearestTimer() # 计算最接近的时间事件距离到达还有多少毫秒 remaind_ms = time_event.when - unix_ts_now() # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0 if remaind_ms &lt; 0: remaind_ms = 0 # 根据 remaind_ms 的值，创建 timeval timeval = create_timeval_with_ms(remaind_ms) # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定 aeApiPoll(timeval) # 处理所有已产生的文件事件 procesFileEvents() # 处理所有已到达的时间事件 processTimeEvents() 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下： 12345678def main(): # 初始化服务器 init_server() # 一直处理事件，直到服务器关闭为止 while server_is_not_shutdown(): aeProcessEvents() # 服务器关闭，执行清理操作 clean_server() 从事件处理的角度来看，服务器运行流程如下： 十一、复制通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 连接过程 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令； 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令； 主服务器每执行一次写命令，就向从服务器发送相同的写命令。 主从链随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 十二、SentinelSentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。 十三、分片分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片：Redis Cluster。 十四、一个简单的论坛系统分析该论坛系统功能如下： 可以发布文章； 可以对文章进行点赞； 在首页可以按文章的发布时间或者文章的点赞数进行排序显示。 文章信息文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。 Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。 点赞功能当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。 为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。 对文章进行排序为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）","link":"/2019/05/24/redis-basic/"},{"title":"消息队列（一）：基础介绍","text":"一.消息模型 点对点消息生产者向消息队列中发送消息，只能被消费一次 发布/订阅和观察者模式有以下不同 观察者模式中，观察者和主题都知道对方的存在，而发布订阅模式中，生产者和消费者不知道对方的存在，他们通过频道通信 观察者模式是同步的，当时间触发时，主题会调用观察者方法，然后等待方法返回。而发布与订阅模式是异步的，生产者向频道发送一个消息后，就不需要关心消费者何时去订阅这个消息，可以立即返回。 二.使用场景 异步处理发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。 例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。 只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。 后续可以添加更多的例子: 日志处理消息通讯（聊天室等） 流量削峰在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。 可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。 应用解耦如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。 通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。 三.可靠性 发送端的可靠性发送端完成操作后一定能将消息成功发送到消息队列中。 实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。 接收端的可靠性接收端能够从消息队列成功消费一次消息。 两种实现方法： 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。 四.优缺点 优点解耦: 每个成员不必受其他成员影响，可以更独立自主，只通过一个简单的容器来联系。提速: 其实就是支持异步操作，能节约大量时间广播: 新同伴新加入成本很低削峰: 遇上突然的大量请求，只需要在多久时间内处理完成即可。 缺点引入复杂度: 需要地方防止，也需要考虑安全性。暂时的不一致性: 这个很好理解，并不等于放入队列就是执行完成。 其实还存在失败的可能性，如果保证顺序执行，且还能重复执行就是另个比较深的问题了。 五.应用场景 生产者不需要从消费者处获得反馈 容许暂时不一致性 产生副作用的效益高于成本","link":"/2019/05/30/something-about-mq/"},{"title":"数据库基础概念","text":"一、数据库事务的四个特性 ACIDAtomicity(原子性) Consistency(一致性) Isolution(隔离性) Durability(持久性) 原子性原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 数据库事物的一致性就规定了事物提交前后，永远只可能存在事物提交前的状态和事物提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态。也就是说事物的执行结果是量子化状态，而不是线性状态。 隔离性事务的隔离性，基于原子性和一致性，因为事物是原子化，量子化的，所以，事物可以有多个原子包的形式并发执行，但是，每个事务相互隔离(具体的隔离级别是按数据库的情况定的)。 当数据库上有多个事务同时执行的时候，就可能出现脏读(dirty read)、不可重复读(non-repeatable read)和幻读(phantom read) 持久性事务只要提交了，数据库状态会永远发生变化，即使宕机了。 二、隔离性特别说明隔离引发的问题脏读(dirty read) 不可重复读(non-repeatable read) 幻读(phantom read) 隔离的四个级别读未提交(read uncommitted) 读提交(read committed) 可重复读(repeatable read) 串行化(serializable) 读未提交一个事务还没提交时，变更就可以被别的事务看到。 读提交一个事务提交之后，它做的变更才会被其他事务看到。 可重复读一个事务执行的过程中看到的数据，总是跟这个事务再启动时看到的数据是一致的。在此隔离级别下，未提交变更对其他事务也是不可见的。 串行化对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。","link":"/2019/06/06/database-basic/"},{"title":"创业的一些参考","text":"今天的这篇文章从反常识的数据开始谈起，基于中国的机遇与优势、实体经济、改变偏见，下沉市场、海外市场，新金融时代等板块，展开对新商业文明时代的看法。 在开启本篇的阅读前，大家先思考两个问题： 1.你真的了解中国嘛？2.你最看重的创业机会有哪些？ 一、九个反常识的数据① 全国约有 90% 以上的人没有喝过星巴克 这是我经过逻辑推理得出的。 去年，星巴克宣布将 700 万星巴克会员接入支付宝。基于这个数据，我做了一系列推理。 如果我们算每 7 个客户有一个开通会员，那么就是 4900 万，10 个里有 1 个是 7000 万。 星巴克在上海的门店是最多的，500 家以上，这个城市 2500-3000 万的人口（含流动），三成喝过的话，是 900 万。 中国目前星巴克的门店数是 3400 家，大多数覆盖在一二线城市。一线新一线二线（含广义二线）的人口总数不超过 3.6 亿，里面三成是 10800 万，2 成是 7200 万（越往下门店很少，渗透率很低，全量来看不超过 1.5 成，以上换算只提供思路，不代表最终实际数据。） 因为我没有准确数据，我只能倒推，无论从哪个角度去倒推，90% 的人都没有喝过星巴克。 故而，知道并不等于喝过，并且一定有海量的人不知道星巴克。以上数据，依然是比较保守的推断。 ② 50% 以上的中国人没有喝过农夫山泉 2016 年，农夫山泉的年销售额达到了 109.11 亿元，其中包含新产品和高端产品，桶装水，会议酒店供水等等。我一年可能要花 2400 元以上在农夫山泉上。 按照这个销售额计算，假设客单价 20 元，那么只有 5 亿多人喝过农夫山泉。 《2018 全球品牌足迹报告》显示，农夫山泉消费者触及数达 3.35 亿。虽然农夫山泉的客单价不高，但是它的受众人群比较集中。 故而，即使这个品牌是大众到不能再大众的了，依然不可能做到人人都喝。 ③ 中国约有 1000 万人从事足疗行业 仅北京市就有 20 万人从事足疗，推算一下，中国有 661 个城市，那么 1000 万这个数字依然是保守的估计。 ④ 13 亿人没有出过国 中国出入境管理局发布，2018 年全国有效的因私普通护照私有量为 1.3 亿本。也就是说，起码有 90% 的中国人没有出过国。 ⑤ 10 亿人没有坐过飞机 为什么每次坐飞机的时候工作人员都会演示一遍安全操作？因为跟你一起坐飞机的人中，起码有一半人是第一次坐飞机。 中国头等舱用户不超过 600 万，每年常旅客不超过 1500 万（年飞行超过 6 次的称为常旅客）。 由此可以看出：在航空杂志投广告，其实就只有那 1500 万常旅客能看到。所以，航空业广告商做廉价产品是行不通的，只有针对那 1500 万人的产品和服务才能实现有效目的。 国航的白金卡用户不超过 5 万人，听说东航不超过 5000 人（除了一些特殊渠道，一年盯着一个航空飞行 120 次经济舱，60 次商务舱，40 次洲际公务舱才能拿到这个白金卡）。 ⑥ 中国最大的便利店不是全家，而是中石化旗下的易捷便利店 每一个中石化加油站旁边都有一个易捷便利店。 目前是中国最大的便利店，有 25000 多家门店，《2018 中国便利店发展报告》显示，易捷便利店占全国便利店超过 20% 的份额，很难被超越。 ⑦ 处于房地产中介金字塔塔尖的，通常是穿着拖鞋、汗衫的二房东 像上海静安区的一些小别墅，还有北京的四合院，都是少量不可再生的，往往这些房子很受欢迎，很多人喜欢租这样的房子。 我们公司租的房子的二房东就是这样的人。 早期做租赁的中介发现这一现象后，就把这些房子一套套收过来进行改装，进而成为二房东。 我大概计算了一下，如果成为 20 套老别墅的二房东，每个月净利润可达 50 万，每套差价在 2-5 万之间，合同一签就是 10 年。 ⑧ 进口猪蹄比国内猪蹄便宜 30%—50% 因为除了中国、德国等少数国家，全世界大多数人不吃猪蹄。在很多国家，猪蹄被当做废品处理，中国人把它收购拿回国内，比在国内采购还便宜。 ⑨ 中国产的棉毛裤在西班牙可以卖 10 倍的价格 过去，欧洲人是不知道世界上还有个东西叫棉毛裤。 中国有个小伙子，把浙江生产的内销不掉的棉毛裤拖到欧洲，在他们冬天特别冷的时候卖，卖得特别好。 二、中国的四大优势和巨大契机如果这四点不发生根本性改变，那么我们依然是有巨大的机会。 ① 中国具有全球最强的终端制造产业链和产业集群 有一次我去印度和埃及，带的是 iPhone 手机，手机上套了一个有 6 个玻璃镜头的手机壳，当地人都非常好奇，问我这是什么？他们根本没有见过这样的手机壳。 6 个镜头的手机壳在中国被认为是低端制造，但其实它在全球属于中端制造了，因为全球绝大多数地区都无法生产出来。 因为这个产品涉及的产业链和零部件非常多，而全世界也只有中国能够最高效、最低价、最批量地生产，并以最大规模的消耗掉。 还有一个现象也很有趣，在中国南部和东部地区，有大量县城变成了一个个产业集群，整个县城都围绕着一个生意展开，在那里走几公里就能找到一切你需要的东西，但在别的国家，这可能是要跨国才能完成的。 对中国制造我有一个基本的判断：中国是全球最强的中端制造大国，没有之一。任何一个国家无 30 年积累，无政策连贯性支持，无法取代中国中端制造的优势。 ② 我们的劳动力已不是全球最便宜的，但是劳动力素质全球最高 现在只有中国的劳动力是最具有勤劳、刻苦精神的。越南、柬埔寨的劳动力确实便宜，非洲的劳动力更低，但是和中国相比，职业技能不可同日而语。 ③ 我们依然是全球最大的消费市场 今天大部分中国人已经改变了储蓄的习惯，乐于消费。 ④ 中国人是全球最渴望改变命运的 印度人都信印度教，印度教告诉你人分等级，这辈子好好修行，下辈子再升级到婆罗门。中国没有这样的教育，中国人都相信通过努力能过得更好一点。 三、在这里，读懂中国关于人口，大多数人对其判断都是非常情绪化的，也是错误的。 一些美国经济学家研究发现：长期高速的经济增长会对国民性格产生很多改变，他们会更乐观、更自信、更积极向上、更开放、更包容。 而这些因素集中体现在今天中国的 00 后身上。 1. 很多农村地区幸福指数远高于城市 农村收入并不高，但他们有宅基地，有自留地，他们可以将自留地租出去，每年收取租金。某些地区，他们的幸福指数很高，远远高于发达地区。 基于大量的观察发现，现在农村里种地的人很少，并且几乎都是机械化种植，很多人会外出打工。 但是在他们眼里，大城市不是他们的世界，老了还是要回去，因为老家还有地。只要想到自己有土地，他们吃再多苦，都是乐意的。 2. 90 后到 00 后的消费观发生很大变化 ① 消费升级 90 后、00 后在社会认同感上的消费，在他们进入社会几年后就会和上一代人趋同，并且更愿意提前完成这种认同感的消费。 他们中很多人的第一辆车一定不是雪佛兰，而是直接进入高端车的低配版，所以奔驰 C 系列、宝马 3 系、宝马 X1 都卖得特别好。 另外，奢侈品年轻化趋势非常明显。在中国，更多女生在 20 多岁左右就开始用 La Mer，而在欧美，更多成熟女性选择它，不仅仅是钱的问题。 我认为 90 后的第一次装修是一波不可再生的资源，并且这波 90 后一定比后面的每一代人都多。 对于装修来说，很多大件，包括家电、家居、甚至小家电，是不会随便更换的，而 90 后的结婚潮已经到来，虽然他们中有很多人选择了不婚和晚婚，但是在压力较小的三四线，这一波行情还是比较明显的。 所以，一定要抓住 90 后的装修升级，如果错过了，可能三五年内都没有消费了。 ② 孤独催生商机 90 后比较懒，还有独生子女病，孤独将催生一大波的商机。 孤独的年轻人喜欢养动物，他们会带宠物去按摩和游泳，等到他们出差的时候，会找个宠物店寄养，一个不到 1 平方米的地方 1 天要花 300 块。 此外，还有专门的宠物殡葬，基于此，宠物市场一定还会扩大，并且每年快速增长。 ③ 比起 KOL，他们更相信真实用户反馈 在腾讯提供的 00 后报告中，我们能够看到，KOL（关键意见领袖）的影响力在下降，比起 KOL，00 后更相信真实的用户反馈。 对于所有品牌主来说，未来的投放会变得很难，因为你需要对接海量的超级用户，并且你要把他们当作一件很重要的事情去运营。 ④ 对国产品牌的认知正在改变 今天，国产品牌并不比国外品牌差，这个问题在 00 后的心目中正在形成。 主要有以下 3 个原因： 第一，中国制造真的在进步； 第二，大量国外品牌把落后的生产线丢到中国，现在才开始重视中国市场，但已经晚了，因为中国品牌的反应速度更快； 第三，00 后成长的年代就是民族自豪感产生的年代。 对于 00 后来说，他们向往在专注领域有深刻见解的品牌。 老一代人恨不得一个产品具备所有功能，但是今天 00 后更喜欢专业领域的、垂直的、优秀的品牌。 ⑤ 00 后的存款是 90 后的两倍 虽然 00 后存款只有 1840 元，但 90 后更少，只有 800 元（数据来源于腾讯最新的 00 后研究报告）。 3.关于人口红利 我们总是很悲观地说人口红利没有了，其实只是分红方式发生了改变。 现在的人口红利正在体现为地区性、结构性和微观性，每个地区不是统一统筹的。 即使目前中国年轻劳动力更少了，但依然在绝对数量上超越了大多数国家，并且中国的劳动力具有素质跟薪资的平衡优势。 不要老是觉得员工就应该给你干什么，这是错的。你首先要思考的是，你能为你的员工干什么，能帮助他们实现什么。 也就是说，梦想要有，但回馈也要有。 4.劳动力总数还在增长 目前我国劳动力还没有衰退，去年农民工总数比上年增长了 0.6%。农民进一步从土地中解放出来。 相比去年，城镇化进一步提高，按照这个趋势，我认为中国的城镇化率未来会像发达国家看齐，达到 70% 左右。 第三季度农民工外出打工获得的收入平均 11130 元。但他们有自留地，还有宅基地。（以上数据全部来自于国家统计局 2018 年） 四、在这里，改变偏见这里我们要分享一下看企业的方法论，我写了很多《在这里改变偏见》系列文章，看起来有的观点很出格，其实有一套严谨的体系。 1.看企业是有方法论的 ① 看顶层设计 顶层先设计好，设计不好后期很难发力。 ② 看战术 战术要跟团队一起看，看团队，高层跟基层要分开看。 员工都觉得老板是个骗子，不相信他的梦想，这是有问题的。你会发现，那些优秀的企业，起码有 30% 的员工非常相信老板，50% 的员工没有那么相信老板，但是觉得老板说得对，就跟着做。 如果你的公司是这样，成功的概率会更高。 ③ 看大市场 如果这个市场很小，你也很难做，所以大市场就是企业发展的天花板。 机遇来自于时间窗口。每过一个阶段，社会要素都会发生变化，在变化的过程中，我们就能找到重新切入存量市场的最大机会。 ④ 看执行 看执行是不是到位，如果执行不到位也是白干。 2.读过书的人认为的内容跟现实需要的内容一般是两回事 我们都说互联网是规模经济，其实互联网在一定程度上是反规模经济的。用户时长是有限的，很多公司都在抢，也就是说买用户的成本非常高，到一定程度后是反互联网规律的。 趣头条之前聘请了很多优秀的编辑，这些编辑精选了很多文章推送给他们的用户，发现这些文章的点开率很低。 后来他们把一篇广场舞教学的视频放到了第一位，而且全量推送给所有用户，点开率高达 10%，也就是说 10 个人中就有一个人看了。 这件事告诉我们，很多时候读过书的人认为的内容跟群众需要的内容是两件事。 3.品牌要做到用户洞察、留客、复购和裂变 最近腾讯的朋友告诉我，又有一些品牌通过小程序的投放实现快速的男装定制，月销 15 万单，单价 200 元。 过去做这事很难，因为男人的钱很难赚，而想要找到他们也很难。 这里面两个事情最关键，一是柔性供应链，二是精准投放。没有这两点，男装定制依然是个小而美的生意。 当我们说到亲子类的账号，我们认为亲子类账号就应该卖婴儿纸尿裤、儿童玩具。但有赞的朋友告诉我，有赞上卖得最好的是零食，是大人用的东西。 为什么呢？因为大人每天被孩子折磨得很痛苦，所以晚上会买一点东西给自己吃。所以我们很多时候对用户的理解是错误的，是偏差的。 有一个网红直播卖白酒，销量是两三天上千万，客单价 900 元。这件事告诉我们，私域流量的时代已经到来了，你必须真正做好用户洞察。 私域流量的运营跟传统投放有三个关键区别：留客、复购、裂变。 以前投放了，人过来了，买了，走了。现在是人进来了你得留住，留住之后让他反复买，反复买完之后你还得让他帮你拉人头，裂变。 今天很多账号只有 2 万粉丝，在很多人眼里 2 万粉丝都不能叫规模，我甚至觉得 2 万粉丝是不可能赚到钱的。 但他们通过做留客，发掘粉丝需求，做好复购、裂变，活得挺不错，这颠覆了我原来的认知。 4.价值百万的金属切割机在快手上卖掉了 在和快手沟通的时候，我发现一件很神奇的事情，价值百万的金属切割机在快手上卖掉了。 过去大家一直以为互联网上只能卖便宜的、高频的、生活必须的东西。 金属切割机是怎么卖掉的呢？他们的方式就是，放一台切割机让它运转，用它把金属球切下来，有一些厂商老板看到这个视频就买了。 最主要的原因是，乡镇企业家都喜欢上快手，所以受众契合，并且这种视频非常直观，是带有销售能力的。 乡镇企业家采购设备，你跟他演示很多 PPT 是没有用的，他要看直观的效果。所以经常有人在快手上做暴力演示。 一个人在快手上卖钓鱼竿，他用鱼竿钓一个 200 斤的桶在空中旋转，下面有人留言说 “这个钓鱼竿在哪里卖，我要买”。这就是效果广告，往往是简单粗暴的。 全国快手播放量 TOP10 的乡镇，第一个是连云港的海头镇，那里有非常多的人通过直播卖鱼。 这些案例给我们提供了一个逻辑：在不同的场景下可以做不同的事情，我们要大胆去思考很多问题。 五、这是一个反智的时代1.书读多了反而让人变得反智 人读书多了，有时候会进入到一个奇怪的现象——反智。 聪明人总是以为自己能搞懂一百种生意就能做好一百种生意，这是彻底错误的，你的一生只需要做好一件事情就可以了。 很多老板的反智出现在，主业都有问题了，还想通过副业救公司，这种情况 99% 是不可能的。 当你的主业出现问题，你应该解决主业问题，而不是去搞副业。不要试图去做不符合你能力模型的业务。 举个例子，我跟马英尧 (尚美生活 &amp; OneZone 创始人) 探讨过很多次小镇青年、下沉市场。 我们能写出 10 万 +、100 万 +，只能证明我们写东西的能力强、总结能力强、逻辑强，不能证明我们去小镇就能做生意，所以不要去做跟你能力模型无关的事情。 不足够热爱的事情你就无法掌握、经营它的本质。一定要热爱，热爱的时候你才能发现别人发现不了的东西。 2.不热闹的行业可能很赚钱 很多人觉得这个行业不热闹，挣不到钱，这就是反智。 挣钱的人是不会告诉他们是挣钱的，更不会告诉你怎么挣钱。事实上，太过热闹的行业才是挣不到钱的，不热闹的行业多是挣钱的。 我在广州认识一个老板，他在珠江口挖沙，利润相当可观。 这个行业热闹吗？不热闹。但是这些才是挣钱的。 升级的成本要低于收入，这是一条常识。但今天很多人是没有这个常识的。 比如你把门店升级的很高端，最后人家只来拍照，不买东西。这是最简单但最容易被忽略的生意的本质。 很多行业的规律是 1%—2% 的企业是赚大钱的，18% 的企业是赚钱的，30% 的企业是持平的，50% 的企业是亏钱的，剩下不赚钱和亏钱的企业，天天在网上说行业走到头了。 3.大谈颠覆的人，往往对这个行业就了解 30% 当你对一个行业了解到 30% 的时候，你会觉得你发现了一个巨大的商机，你要颠覆这个行业。了解 70% 的时候，信心崩塌了，原来你所思考的一切问题已经有人思考过了。等你扛到 90% 的时候，你会发现你已经没有太多对手了，过了 95% 之后，你面对的只有几个玩家了。 每个行业都有金线，我们一定要找到那条线，找不到你就永远不可能得道。 4.很多的悲观都是情绪化的悲观 在消费方面，我举一组例子： 家里有两套房，兜里还有 100 万，贷款 300 万，股市套牢 50 万，心情很不好，但是该吃吃该喝喝什么都不少。 家里一套房，兜里 50 万，没有贷款，上升无望，心情很不好，但是该吃还得吃该喝还得喝。 家里没有房，兜里有 10 万，打算买房，但觉得有点远，但是该吃还得吃该喝还得喝。 很多的悲观都是情绪化的悲观。 看消费，看什么？看工业，看发电量，看高速公路。高速公路上没车了，发电量大幅度下降了，那可能真的有问题了。这些数值没有特别大的波动，大概率上问题还不是很大。 清朝的时候，有一场战争叫雅克萨战役，俄国人跟大清打了一仗，后来清朝赢了，但赢得非常艰难。 俄国当时已经装备了最先进的火枪，火枪队对清兵形成了很大的威胁。 大清有大炮，最后大清用大量的红衣大炮压制住了火枪，但是大清没有意识到火枪才是更先进的装备。 这个时代也是如此，很多时候企业最后看起来赢了，但依然是上一个时代的优势，你认为应该加强这个优势，但其实世界已经改变了。 到下一个节点，你的大炮就是废铁了。 5.炫耀从不改变，只是方式发生了改变 今天，很多人觉得过了那个阶段，人就不会炫耀了。我觉得这是瞎说，你的 LOGO 是不见了，但是你每天都把儿子的私立学校挂在朋友圈。 为什么你在上班的时候发的朋友圈都没有定位，但是到了普吉岛和洛杉矶都要带上定位？ 这都是炫耀。 炫耀从来没有改变过，只是方法在不同的人群里有了一定变化。我们只要抓住这个变化就能找到一些规律。 6.靠勤快致富的行业都需要尊重本质 前段时间我写了一篇文章叫《世间没有新零售》，我认为世间没有 “新零售”，只是零售变新了。 本质是零售，而不是新，本质性的问题从来没有变化过，租金、押金、账期、人员、招募、管理、培训、预防、物流仓储、周转率、坪效、人效，轰轰烈烈四年的新零售创业，只让中介、装修队和物业赚到了钱。 线上线下打通对于大多数企业是不成立的，因为当你的用户不是全量用户的时候，两端用户是匹配不上的。 中国目前很多行业都称为 “勤行”，所有靠勤快致富的行业都需要尊重本质。 我以前开了十几家果汁店、餐厅，倒了一半，后来我得出结论，不是道理说得很明白你就能把事情做好。 7.新人爱说跨界打击，基本上是跨界来被打击 跨界打击的前提是你要打的那个人，他会的你都会，他不会的你也会。 他会的你不会，还没到你的时候，你就被他打败了。 社会零售的总需求增长已经放慢，慢于渠道分化的速度，这就意味着五年之内很多渠道将彻底垮了，崩塌了。 8.消费升级也体现在更精简的 SKU（库存量单位） 最近网易严选之所以出了很多问题，是因为它的 SKU 更多，其实它应该做更少的 SKU 满足 80% 的需求，而不是为了那 20% 的需求去制造 80% 的麻烦，这是很重要的。 很多时候花里胡哨的东西只能满足一小群人。 京东京造上有一个很重要的品种，叫乳胶枕，卖得特别好。 今天，我们对国货的信任度正在快速提高，在京东平台上，男性的转化率高于女性，尤其是在这种类型的消费升级。 9.直播最重要的不是直播，是叫大哥 制造垃圾快乐是当下最高效的吸金方式，小程序算命、逆袭小说、小姐姐直播，大家都喜欢看。 什么样的人最喜欢在直播平台打赏？就是有钱但是平时生活里没有人重视的人。 这个秘密我是怎么知道的？当年我开店的时候，跟一个包工头老板聊天，他说他一年打赏花了 10 万，但他是他们圈子里打赏最少的，其他人打赏都是 100 万起步。 后来我研究了一下，那些包工头每年能赚几百万，甚至几千万。但是在工商界，很多人都觉得他们比较 LOW，不能上台面，他们很失落，所以他们喜欢去直播平台打赏。 很多人为了被口播，会花大量的钱，在直播平台，他们能获得尊重和荣耀。所以直播的本质是口播，而不是直播。 六、再看实体经济实体经济，实体品牌，只要本质不发生改变，就永远会有喜新厌旧、物极必反的机会。 举个例子，前几年女生喜欢买蔻驰的包，结果地铁一打开，一节车箱出现了 10 个蔻驰。 于是她们找到了下一个品牌，过了一年半载，地铁打开又是 10 个这个品牌，她们又去换别的牌子，这就叫物极必反，喜新厌旧。 新国货崛起两条路最靠谱： 第一个是主打性价比，高质量、高逼格、中低价格；第二个是主打圈层高、质量高价格。 1.工厂的转型之路 今天的中国工厂，过得好的有两种： 一种是做短线，做高质量、低价格、**针对 C2M（顾客对工厂）模式的产品，**然后通过各种平台快速消化，只有这样才能保持产线运作、保持工厂流水。但是没有品牌只能解近渴。 一种是做长线，做高逼格、低价格的品牌。也就是在初期用规模换空间，用规模降成本，中期要思考如何做成一个品牌。 但是，做长线的企业里，大部分工厂很难出品牌。因为没有这样的基因，它的顶层设计和团队都是错的。 比如高薪挖来一个人做品牌，又不很信任，也不放权，非要用自己的产线思维去管人家的品牌思维，这也是不行的。所以基本上能实现迭代的工厂仍旧不多。 2.四类产品的降维打法 我们可以通过一个区隔方式把产品分成四种： ① 功能属性的产品优衣库化 什么叫做优衣库化？优衣库最早进入美国市场的时候开在沃尔玛边上，因为开在乡下没有人买，觉得这是很 LOW。 优衣库是做怎么起来的？它把重金花在了最好的街头，开最好的旗舰店，打造一个中产阶级偏高的象征的东西和品质感，但是它的价格是偏低的。把快消品的功能性做成一种符号，一种腔调，才能赢得人心。 ② 身份属性的产品奢侈品化 身份属性的产品奢侈化，但是它是功能属性为主。 我觉得功能属性就是即使性价比很强，也很难成为企业家需要的东西，或中产阶级偏上及中产需要的东西。 这里必须去打造你的区隔感，身份属性的东西要做的高级，要有奢侈品的感觉。 ③ 高频消耗品上瘾化 高频的消耗品一定要带有一定的上瘾化，如果你不能上瘾，不能形成某一种触觉和连接的感觉，你是很难做好这个生意的。 举个例子，很多人抽烟并不是为了抽烟，他就喜欢手里有个东西，让它成为一种衍生的器官。创造上瘾的特性很重要。 牙膏在最早推出的时候不起泡沫，但产品经理发现，如果没有泡泡、没有薄荷味道，很难让人上瘾，觉得牙膏没效果。所以牙膏有泡泡、很清凉，消费者觉得这样才有效，产品就普及了。 也就是说，你的产品可以加一点没有实际作用、但能让人上瘾的东西。 ④ 低频耐耗品信仰化 今天很多大家电其实是属于耐耗品，一定要有信仰、有圈层。 2.行业现象 ① 卤制品 中国卤制品行业是一个高度分散的行业，行业研报数据是 2500 亿，但是因为有大量不开票的现象（菜场、小作坊、路边摊等等），所以业内甚至有人预估是 8000 亿。 绝味鸭脖是行业头部企业，大概一年 40 亿营收。所以这是一个离散度很高的产业。也就是说：你还有机会在一个地区生产出一个几个亿的卤制品品牌。 ② 乘用车 目前中国的乘用车市场遇到一个很重要的问题，产量和销量的差值正在扩大，意味着大量库存的产生。怎么解决？ 我有两个想法，首先中低产线的车可能会通过更好的网约车制度解决，让车更好的共享。其次，走向海外。非洲都是日韩品牌车为主，中国车在那里的市场份额并没有我们想象中的大。 ③ 美发店、推拿 如果不是从基层爬起来的，创业的成功概率低于 10%。 ④ 家纺 过去我们总认为纺织业已经没有任何利润了，这是错的，安踏毛利率 52.6%，净利率 24.9%。 申洲国际做代工，毛利率 31.6%，净利率能达 24.8%，耐克是它最大的客户之一，都没它高。全球大多数的运动类顶级品牌都是它代工的。 申洲国际告诉我们一件事，实体产业做到极致的时候，就拥有了话语权跟绝对优势。 很多工厂比申洲国际更便宜，但是不能大规模的出货，能大规模出货不能垫得起那么多的钱，能垫得起那么多钱，很难保证大规模出货的质量是稳定的。这是实体经济的壁垒，跟互联网说的壁垒是两件事情。 ⑤ 酱油和醋 中国 TOP1 的酱油公司是海天酱油，截止到 4 月 17 日市值 2327 亿，总占有率是 18%，净利率是 30.5%。也就是说，很赚钱的是实体产业，比如酱油这种不怎么起眼的行业。 ⑥ 食品类跨国企业 全球 TOP1 食品类跨国企业是雀巢，它收购了大量企业，但是那些企业并没有用雀巢这个名字。 去年，雀巢在全球有 6000 多亿人民币销售额，净利润 670 亿。 所以我一直强调的是：我们要敬畏国际的巨头。 你融了一个亿就觉得自己牛，但是人家一年利润 670 亿，一天接近两个亿，这就是人家造钱的速度，十年之功不可能一日形成的。 ⑦ 内衣 有一个品牌叫 Lululemon，最早做女性运动内衣，现在也做男性产品。 Lululemon 给品牌赋予精神、赋予圈层感、赋予科技感。我在五年前去香港，在时代广场看到 Lululemon 旗舰店，层高最高都七八米，跟苹果旗舰店差不多。 ⑧ 海底捞 以前我们是向所有人做一种生意，现在是围绕着一群人做所有生意。 海底捞给我们的启示是，什么部门都能赚钱。海底捞把财务部门做成了财务咨询公司，工程部顺便给别人搞装修，火锅调料也单独上市了。 这个时代要充分的挖掘你公司现有的能力，快速把它变成赚钱的东西。 3.品牌溢价 人会为了巨大的快感支付超额的溢价，但是每个人的快感来源是不大一样的。 男人可以为三件事情付钱，快感、存在感、认同感。如果你给男性做产品没有这三个标准，不能说你做不好，你捞不到最多的钱。 我们一定要想清楚，头等舱休息室里的咖啡不好喝，面也不好吃。但是为什么那么多人就要待在那里喝咖啡？这里有很多内心的真实的洞察，我们一定要想明白，这对于做品牌非常重要。 七、再看下沉市场一线的人最大的问题就是从来不会迈出他的 CBD 半步，但是每天思考怎么去赚那些人的钱。这根本就难以实现。 这里分享几个关于下沉市场的观点和事实。 1.二线跟三线是两类城市，不要混在一起说 二线都有产业聚集，就业岗位明显高于三线城市，所以二线对人才的吸附能力是三线的很多倍。 2.三线城市新城区和老城区泾渭分明 比如泉州，老城区特别古老，我在那里的感觉就是回到了 80 年代。但是它的新城，万达广场特别大，万达在边上盖了一个特别大的小区，里面什么品牌都有，和上海的 CBD 没什么区别。 3.消费品市场的喜好是完全不一样的 玖姿这个品牌的定位就是卖给小镇贵妇，就是下沉市场的中产女性的品牌。但是我打听了一圈，一线基本没人知道。 在农村，80 寸电视机卖得非常好。但一线城市家里放不下 80 寸的电视机。因为中国一线的年轻人都是租的房子，没有客厅。 4.存量改造是一门巨大的生意 包括 4S 店改造、酒店改造、家居行业改造、零售改造、家电 3C 的改造。 一、二线城市现在 3.6 亿人口，4.75 亿手机，人均 1.3 台，下沉市场人均 0.5 台，两个人里还有一个人没有手机。 5.理性认识小镇青年 中国过去 40 年的发展来自于三点：全球化、工业化和城市化。 改革开放之初，中国不超过 5% 的人是城里人，95% 以上的人都是小镇青年，即使今天身份证上是北京人，是城市人，但是内心骨子里依然有小镇青年的影子，这是品牌必须理解的一件事情，用数据系统打标是不能解决所有的洞察问题。 总结一句，所有品牌的升级都是围绕一句话完成的：渴望和大城市的人一样。 另外如果今天你还指望跟我聊下沉市场，而不是自己去看，那么这个生意已经跟你没有什么大关系了。 八、出海再造一个经济体1.出海并非单纯复制 中国的出海分两种： 一种是以中国为母本向海外输出，一种是直接以海外为母体。 以印度为例。 一直在说印度是下一个中国，我认为这是一件低概率事件。 有一组数据很重要，三四年前，中国、印度、越南全国年龄中位数，中国已经是 37 岁，今年差不多 40 岁，但是印度只有 30.4 岁，越南更小只有 26.7 岁。 印度的 GDP 只有 2 万亿，中国是 13 万亿，还没有到中国的零头。人均 GDP 目前刚突破 1900 美元，但它的人口结构跟中国改革初期是差不多的。 有一个更值得我们现在关心的市场叫做东南亚市场。 东南亚 11 个国家最富的是新加坡，最穷的是缅甸，新加坡除以缅甸，人均 GDP 差了 46.7 倍。区域市场差异相当大。 2.出海非洲的 “坑” 非洲是一个复杂的多元化的市场，非洲的总体经济，由北向南越来越差。 非洲的坑在哪里？它的单体存量很小，市场很分散，所以我们要做的是什么？简单的可复制的生意是做不了的。 在非洲有一个品牌做得特别好，叫传音。 它是如何进入非洲市场的？ 首先它从尼日利亚开始做，发现非洲电力供应不是很稳定，手机充电会很麻烦，于是它把手机电池做成 3000 毫安。 同时少标一点容量，这会让别人觉得你的电力特别持久。 其次，非洲经济比较拮据，人们会使用多个电话卡，因为有优惠套餐，传音成了第一家把双卡双待、四卡四待引入到非洲的企业。 富贵和贫穷是一样的，都会限制人们的眼界和思考能力。 九、新金融时代巨量的隐形市场 未来的公司，没点金融能力都不能叫公司了。积分化、证券化、金融化是重要的方向。 积分、里程是一个巨大的市场。美国运通每年向美国航空集团采购积分要花 10 亿美金。 信用飞这家公司正在做的便是如何将中国几十家航空公司的积分能够打通，这件事如果做成了就会变成一个巨大的生意。 携程，现在最赚钱的业务是卖保险。别小看卖延误险，它的利润特别高。 在中国民营企业里，蚂蚁金服应该是在金融层面做的最好的之一。蚂蚁金服好在哪里呢？它在向线下延伸的时候，向小业主延伸，除了前端收款，后端还放贷。 我一直觉得中国有个很大的市场就是中小商户的市场。 你不要觉得所有人都能办出信用卡，有的人办不出信用卡。 今天的中小企业，尤其是小微企业能通过阿里贷款，我认为这件事情如果能真的彻底做好是非常大的市场，比做前端新零售强多了，后端解决零售里的现金流问题，是新零售的重要组成部分。 摘自微信公众号笔记侠10 亿人没有坐过飞机，00后存款是90后的两倍……颠覆你的58个认知","link":"/2019/05/24/start-up-business/"},{"title":"数据库基础概念 索引","text":"常见的索引类型 MySQL的索引B+Tree 和 BTree B+Tree BTree 数据库的一些短问题 B+tree的N叉树，N是由什么决定的N叉树是由页大小和索引大小决定的 删除数据后索引不会被删除某种情况下导致一个项目的数据库表大小10G，索引大小30G。 如果是主键的话，重建表可以重建主键索引。 因为无论删除主键和新增主键都会重建表，所以直接重建表 1alter table T engine=InnoDB 如果是非主键索引，drop后添加即可。 12alter table T drop index k;alter table T add index(k); 数据库的一些长问题一个表结构定义如下的一张表 12345678910CREATE TABLE `geek` (`a` int(11) NOT NULL,`b` int(11) NOT NULL,`c` int(11) NOT NULL,`d` int(11) NOT NULL,PRIMARY KEY (`a`,`b`),KEY `c` (`c`),KEY `ca` (`c`,`a`),KEY `cb` (`c`,`b`)) ENGINE=InnoDB; 但是既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”`“cb”`这两个索引？ 如果为了解决如下使用场景添加的索引是否合理。 12select * from geek where c=N order by a limit 1;select * from geek where c=N order by b limit 1; 答案如下： 表记录 a b c d 1 2 3 d 1 3 2 d 1 4 3 d 2 1 3 d 2 2 2 d 2 3 4 d 主键 a，b 的聚簇索引组织顺序相当于 order by a,b，也就是先按 a 排序，再按 b 排序，c 无序。 索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键 c a 主键部分b （注意，这里不是ab，而是只有 b） 2 1 3 2 2 2 3 1 2 3 1 4 3 2 1 4 2 3 这个跟索引 c 的数据是一模一样的。 索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键 c b 主键部分a（注意，这里不是 ab，而是只有 a） 2 2 2 2 3 1 3 1 2 3 2 1 3 4 1 4 3 2 所以，结论是 ca 可以去掉，cb 需要保留。 事务A 事务B begin transaction begin transaction select * from payment where id = A select * from payment where id = A insert B insert C update A(比如就更新status) commit update A commit A(比如就更新status)","link":"/2019/06/07/database-more/"},{"title":"node-schedule的一些分析","text":"先介绍下这个包是干嘛的 node-schedule是一个A cron-like and not-cron-like job scheduler for Node 这个包可以做到在node环境中实现定时触发某些任务的效果。 使用方法在github文档里面都找的到我这里就不赘述了。 为啥会找到这个包因为项目无法自动化。定时任务部分的设置，在上线的时候需要手动的在服务器的cron上面去设置，所以成为了自动化部署的阻碍。所以想要改变这种情形于是想起来之前同事推荐的这个库。 具体的应用场景项目中会有些在半夜执行触发的定时任务，此时会通过直接调用内部API的方式进行触发。 产生了疑惑我比较好奇这个是怎么实现定时任务的。比如我传了一个cron format格式的时间。他怎么做到能够按这个时间执行的嘞。 源码的观察我将源码首先先看这部分代码 123456789101112131415161718function scheduleJob() { if (arguments.length &lt; 2) { return null; } var name = (arguments.length &gt;= 3 &amp;&amp; typeof arguments[0] === 'string') ? arguments[0] : null; var spec = name ? arguments[1] : arguments[0]; var method = name ? arguments[2] : arguments[1]; var callback = name ? arguments[3] : arguments[2]; var job = new Job(name, method, callback); if (job.schedule(spec)) { return job; } return null;} 会先去new Job 那么就去找Job的实现方法。Job的实现方法太长了就不全贴出来了 12345678// Make sure callback is actually a callback if (this.job === name) { // Name wasn't provided and maybe a callback is there this.callback = typeof job === 'function' ? job : false; } else { // Name was provided, and maybe a callback is there this.callback = typeof callback === 'function' ? callback : false; } 这段就知道会对callback进行执行。如果想要最快的找到怎么实现定时的实现。那么既然要找到执行这个callback的方法，毕竟到点了肯定是执行传入的回调的。 123456789101112131415161718192021222324252627282930313233function prepareNextInvocation() { if (invocations.length &gt; 0 &amp;&amp; currentInvocation !== invocations[0]) { if (currentInvocation !== null) { lt.clearTimeout(currentInvocation.timerID); currentInvocation.timerID = null; currentInvocation = null; } currentInvocation = invocations[0]; var job = currentInvocation.job; var cinv = currentInvocation; currentInvocation.timerID = runOnDate(currentInvocation.fireDate, function() { currentInvocationFinished(); if (job.callback) { job.callback(); } if (cinv.recurrenceRule.recurs || cinv.recurrenceRule._endDate === null) { var inv = scheduleNextRecurrence(cinv.recurrenceRule, cinv.job, cinv.fireDate, cinv.endDate); if (inv !== null) { inv.job.trackInvocation(inv); } } job.stopTrackingInvocation(cinv); job.invoke(cinv.fireDate instanceof CronDate ? cinv.fireDate.toDate() : cinv.fireDate); job.emit('run'); }); }} 这段代码里面找到了job.callback()，可以看到执行条件为runOnDate那么就到了解谜的时候了。 123456789101112/* Date-based scheduler */function runOnDate(date, job) { var now = Date.now(); var then = date.getTime(); return lt.setTimeout(function() { if (then &gt; Date.now()) runOnDate(date, job); else job(); }, (then &lt; now ? 0 : then - now));} 会发现这玩意是在头部引用的一个外部包lt就是lt = require('long-timeout')这个项目还是挺简单的，会发现基本就是对于setTimeOut的一个封装。 结论到此为止结论就显而易见了 这个库做到定时执行的根本是基于setTimeOut的。 通过之前对于Node.js的时间循环的分析，可以知道，timer阶段的执行不一定是严格按照那个时间来的。会受整个Node循环执行情况的影响。 所以如果需要精确到很精确的时间，还是得通过别的方案来解决，如果这个不算太精确的时间可以接受，那么把定时任务模块拆出来，通过这个定时任务模块来实现，也不失为一种方式。","link":"/2019/06/25/node-schedule-read/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"观点","slug":"观点","link":"/tags/观点/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"消息队列","slug":"消息队列","link":"/tags/消息队列/"},{"name":"设计","slug":"设计","link":"/tags/设计/"},{"name":"创业","slug":"创业","link":"/tags/创业/"},{"name":"思路","slug":"思路","link":"/tags/思路/"},{"name":"索引","slug":"索引","link":"/tags/索引/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"}],"categories":[{"name":"日记","slug":"日记","link":"/categories/日记/"},{"name":"技术","slug":"技术","link":"/categories/技术/"},{"name":"杂谈","slug":"杂谈","link":"/categories/杂谈/"}]}